// Small lib to parse nhmmer.table files
// generated by the flag `--tblout`

use std::{
    fs,
    io::{self, BufRead},
    path::PathBuf,
    process::Command,
    str::FromStr,
};

static TABLE_PATH: &str = "./hmm_tables";

/// Entry point for running hmmer
pub fn run_hmmer(
    mitochondrial_genome_path: PathBuf,
    nhmmer_exec_path: PathBuf,
    hmm_path: PathBuf,
) -> Result<(), Box<dyn std::error::Error>> {
    // the dir where the HMMs live.
    let hmms = fs::read_dir(hmm_path)?;

    for hmm in hmms {
        // sort out the HMM path
        let hmm_path = hmm.expect("Could not open HMM path").path();
        eprintln!(
            "[+]\tRunning nhmmer with HMM: {}",
            hmm_path.clone().display()
        );

        let hmm_name = hmm_path.file_name().unwrap().to_str().unwrap();

        // create dir where the output HMM tables should go
        if !fs::metadata("./hmm_tables").is_ok() {
            fs::create_dir("./hmm_tables")?;
        }
        // get basename of mitochondrial_genome_path
        let bn_mgp = mitochondrial_genome_path
            .as_path()
            .file_stem()
            .unwrap()
            .to_str()
            .unwrap();
        let hmm_table = format!("./hmm_tables/{}-{}.table", hmm_name, bn_mgp);

        let output = Command::new(&nhmmer_exec_path)
            .arg("--tblout")
            .arg(hmm_table)
            .arg(hmm_path)
            .arg(&mitochondrial_genome_path)
            .output()
            .expect("failed to execute process");

        assert!(output.status.success());
    }

    Ok(())
}

#[derive(Debug, Hash, Eq, PartialEq)]
enum MitoGene {
    Atp1,
    Atp4,
    Atp6,
    Atp8,
    Atp9,
    CcmB,
    CcmC,
    CcmF,
    Cob,
    Cox1,
    Cox2,
    Cox3,
    MatR,
    MttB,
    Nad1,
    Nad2,
    Nad3,
    Nad4,
    Nad5,
    Nad6,
    Nad7,
    Nad9,
    Rpl2,
    Rpl5,
    Rpl10,
    Rpl16,
    Rps1,
    Rps3,
    Rps4,
    Rps10,
    Rps12,
    Rps13,
    Rps14,
    Rps19,
    Sdh3,
    Sdh4,
}

impl FromStr for MitoGene {
    type Err = &'static str;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "atp1" => Ok(MitoGene::Atp1),
            "atp4" => Ok(MitoGene::Atp4),
            "atp6" => Ok(MitoGene::Atp6),
            "atp8" => Ok(MitoGene::Atp8),
            "atp9" => Ok(MitoGene::Atp9),
            "ccmB" => Ok(MitoGene::CcmB),
            "ccmC" => Ok(MitoGene::CcmC),
            "ccmF" => Ok(MitoGene::CcmF),
            "cob" => Ok(MitoGene::Cob),
            "cox1" => Ok(MitoGene::Cox1),
            "cox2" => Ok(MitoGene::Cox2),
            "cox3" => Ok(MitoGene::Cox3),
            "matR" => Ok(MitoGene::MatR),
            "mttB" => Ok(MitoGene::MttB),
            "nad1" => Ok(MitoGene::Nad1),
            "nad2" => Ok(MitoGene::Nad2),
            "nad3" => Ok(MitoGene::Nad3),
            "nad4" => Ok(MitoGene::Nad4),
            "nad5" => Ok(MitoGene::Nad5),
            "nad6" => Ok(MitoGene::Nad6),
            "nad7" => Ok(MitoGene::Nad7),
            "nad9" => Ok(MitoGene::Nad9),
            "rpl2" => Ok(MitoGene::Rpl2),
            "rpl5" => Ok(MitoGene::Rpl5),
            "rpl10" => Ok(MitoGene::Rpl10),
            "rpl16" => Ok(MitoGene::Rpl16),
            "rps1" => Ok(MitoGene::Rps1),
            "rps3" => Ok(MitoGene::Rps3),
            "rps4" => Ok(MitoGene::Rps4),
            "rps10" => Ok(MitoGene::Rps10),
            "rps12" => Ok(MitoGene::Rps12),
            "rps13" => Ok(MitoGene::Rps13),
            "rps14" => Ok(MitoGene::Rps14),
            "rps19" => Ok(MitoGene::Rps19),
            "sdh3" => Ok(MitoGene::Sdh3),
            "sdh4" => Ok(MitoGene::Sdh4),
            _ => Err("Gene not present in the current set of genes."),
        }
    }
}

#[derive(Debug)]
enum Strand {
    Positive,
    Negative,
}

impl FromStr for Strand {
    type Err = &'static str;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "+" => Ok(Strand::Positive),
            "-" => Ok(Strand::Negative),
            _ => Err("The input was neither `-` nor `+`."),
        }
    }
}

#[derive(Debug)]
pub struct NhmmerRow {
    query_name: MitoGene,
    hmm_from: i32,
    hmm_to: i32,
    ali_from: i32,
    ali_to: i32,
    env_from: i32,
    env_to: i32,
    sq_len: i32,
    strand: Strand,
    e_value: f32,
    score: f32,
    bias: f32,
}

#[derive(Debug)]
pub struct Nhmmer {
    pub rows: Vec<NhmmerRow>,
}

impl Nhmmer {
    /// A new Nhmmer instance.
    pub fn new() -> Self {
        Self { rows: vec![] }
    }

    ///
    pub fn read_tables_and_parse(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let tables = fs::read_dir(TABLE_PATH)?;

        for table in tables {
            let table_path = table.expect("Could not open table path").path();

            let table_file = fs::File::open(table_path)?;
            let table_file_lr = io::BufReader::new(table_file).lines();

            for line in table_file_lr {
                let l = line?;
                if l.starts_with("#") {
                    continue;
                }
                let l_vec = l.split_whitespace().collect::<Vec<&str>>();

                let row = NhmmerRow {
                    query_name: l_vec[2].parse::<MitoGene>()?,
                    hmm_from: l_vec[4].parse::<i32>()?,
                    hmm_to: l_vec[5].parse::<i32>()?,
                    ali_from: l_vec[6].parse::<i32>()?,
                    ali_to: l_vec[7].parse::<i32>()?,
                    env_from: l_vec[8].parse::<i32>()?,
                    env_to: l_vec[9].parse::<i32>()?,
                    sq_len: l_vec[10].parse::<i32>()?,
                    strand: l_vec[11].parse::<Strand>()?,
                    e_value: l_vec[12].parse::<f32>()?,
                    score: l_vec[13].parse::<f32>()?,
                    bias: l_vec[14].parse::<f32>()?,
                };

                self.rows.push(row);
                // only interested in highest scoring hit for now.
                break;
            }
        }

        Ok(())
    }
    /// something to choose lowest e values (if there are a bunch)
    ///
    pub fn filter_table_and_print(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // filter the rows on some E - value threshold
        self.rows.retain(|row| row.e_value < 0.001);

        Ok(())
    }
}
